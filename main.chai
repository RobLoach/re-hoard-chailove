/*
re-hoard
copyright tinglar 2017-2018
license gplv3 (gnu.org/licenses/gpl-3.0.en.html)
revision 0

title music by 0xabad1dea
gameplay music based on song by tanner helland
*/



/*parameters*/

//internal constants
global FLOOR_CELL = false
global WALL_CELL = true
global WALL_STRENGTH = 0.8
global INITIAL_DUNGEON_SIZE = 15
global CORNERS = [ 
	[0, -2],	//north
	[2, 0],		//east
	[-2, 0],	//west
	[0, 2]		//south
]


//internal variables
global currentMusic
global titlePhase = true
global intermissionPhase = false
global setupPhase = false
global normalPhase = false
global panicPhase = false
global startup = true
global currentLevel = 0
global previousLevel = 0
global tries = 3
global incrementor = (currentLevel / 2) * 2
global currentDungeonSize = INITIAL_DUNGEON_SIZE + incrementor
global dungeon = []
global allFloorLocations = []
global opponentSetupFloorLocations = []
global safeFloorLocations = []
global collisionWorld = []
global opponentList = []
global hazardList = []
global treasureLocation = []
global gotTreasure = false
global isFireballThere = false
global fearCount = 0
global arrowCount = 0
global surpriseCount = 0
global dynamiteCount = 0
global highestRound = 0


//translatable variables
global language
global sprite_titleScreen
global message_copyright = "Tinglar 2017‒2018"
global message_pressA
global message_highestRound
global message_currentRound
global message_tries
global message_gameOver
global message_finalRound



//push_back()
//pop_back()

/* data structures */




/* algorithms */
def Translate() {
	if (language == "eng") {
	sprite_titleScreen = love.graphics.newImage("sprites/title.png")
	message_pressA = "Press A."
	message_highestRound = "Highest Round: " + (highestRound + 1)
	message_currentRound = "Round " + (currentLevel + 1)
	message_tries = "Tries: " + tries
	message_gameOver = "Game Over"
	message_finalRound = "Final Round: " + (currentLevel + 1)
	}
	
	else if (language == "spa") {
	sprite_titleScreen = love.graphics.newImage("sprites/title.png")
	message_pressA = "Oprima A."
	message_highestRound = "Ronda Más Alta: " + (highestRound + 1)
	message_currentRound = "Ronda " + (currentLevel + 1)
	message_tries = "Intentos: " + tries
	message_gameOver = "Acabó el Juego"
	message_finalRound = "Última Rona: " + (currentLevel + 1)
	}
	
	else if (language == "epo") {
	sprite_titleScreen = love.graphics.newImage("sprites/title.png")
	message_pressA = "Premu A."
	message_highestRound = "Plej Alta Raŭndo: " + (highestRound + 1)
	message_currentRound = "Raŭndo " + (currentLevel + 1)
	message_tries = "Provoj: " + tries
	message_gameOver = "Finis la Ludo"
	message_finalRound = "Fina Raŭndo: " + (currentLevel + 1)
	}
	
}


def TitleScreen() {
	love.graphics.clear()
	love.graphics.draw(sprite_titleScreen, 32, 32)
	love.graphics.print(message_copyright, 40, 64)
	love.graphics.print(message_pressA, 48, 84)
	love.graphics.print(message_highestRound, 0, 120)
}


def TitleRun() {
	currentMusic = love.sound.newSoundData(music_title)
	currentMusic.play()
	
	if ( love.joystick[0].isDown("A") ) {
		titlePhase = false
		intermissionPhase = true
		IntermissionScreen()
	}
}


def IntermissionScreen() {
	love.graphics.clear()
	love.graphics.print(message_currentLevel, 50, 56)
	love.graphics.print(message_tries, 31, 70)
}


def IntermissionRun() {
	currentMusic = false
	currentMusic.play()
	
	if ( love.joystick[0].isDown("A") ) {
		intermissionPhase = false
		setupPhase = true
		GameSetup()
	}
}


def gameSetup {
}


def Average(a, b) {
	return (a + b) / 2 
}


def DungeonStructure() {
	for (var vertical = 0; vertical < currentDungeonSize; ++vertical) {
		for (var horizontal = 0; horizontal < currentDungeonSize; ++horizontal) {
			dungeon[vertical][horizontal] = WALL_CELL
		}
	}
}

def PlanDungeon() {
	var horizontal = ( love.math.random(1, currentDungeonSize) ) + 1
	var vertical = ( love.math.random(1, currentDungeonSize) ) + 1
	
	if (horizontal % 2 == 1) {
		if (horizontal == currentDungeonSize) {
			horizontal = currentDungeonSize - 1
			}
		else {
			horizontal = horizontal + 1
		}
	}	
	if (vertical % 2 == 1) {
		if (vertical == currentDungeonSize) {
			vertical = currentDungeonSize - 1
			}
		else {
			vertical = vertical + 1
		}
	}
	
	WalkDungeon(horizontal, vertical)
	DemolishDungeon(currentDungeonSize, currentDungeonSize)
}


// fisher-yates shuffle from http://santos.nfshost.com/shuffling.html
def Shuffle(queue) {
	for (var index = 0; index < (queue.length() - 1); ++index) {
		var random = love.math.random(0, index)
		var basin = queue[index]
		queue[index] = queue[random]
		queue[random] = basin
	}
}

def WalkDungeonWalk(width, height) {
	dungeon[height][width] = FLOOR_CELL
	var directions = [1, 2, 3, 4]
	
	Shuffle(directions)
	for (var index : directions) {
		var horizontal = width + corners[index][0]
		var vertical = height + corners[index][1]
		if ( dungeon[vertical][horizontal] ) {
			dungeon[ average(height, vertical) ][ average(width, horizontal) ] = FLOOR_CELL
			WalkDungeon(horizontal, vertical)
		}
	}
}

def DemolishDungeon(width, height) {
	var demolitionForce = 0
	
	for (var vertical = 1; vertical < height - 2; ++vertical) {
		for (var horizontal = 1; horizontal < width - 2; ++horizontal) {
			demolitionForce = love.math.random(0.0, 1.0)
			if (demolitionForce >= WALL_STRENGTH) {
				dungeon[vertical][horizontal] = FLOOR_CELL
			}
		}
	}		
}


def DrawDungeon() {
	for (var vertical = 0; vertical < currentDungeonSize - 1; ++vertical) {
		for (var horizontal = 0; horizontal < currentDungeonSize - 1; ++horizontal) {
			if (dungeon[vertical][horizontal] == WALL_CELL) {
				love.graphics.draw(sprite_wall, (horizontal - 1) * 8 + 1, (vertical - 1) * 8 + 1)
			}
			else {
				love.graphics.draw(sprite_floor, (horizontal - 1) * 8 + 1, (vertical - 1) * 8 + 1)
			}
		}
	}
}


def CollectFloorCells() {
	for (var vertical = 0; vertical < currentDungeonSize - 1; ++vertical) {
		for (var horizontal = 0; horizontal < currentDungeonSize - 1; ++horizontal) {
			if (dungeon[vertical][horizontal] == FLOOR_CELL) {
				allFloorLocations.push_back( [horizontal, vertical] )
			}
		}
	}
}


def CollectOpponentSetupCells() {
	var topHalfOfDungeon = currentDungeonSize / 2
	
	for (var index = 0; index < totalFloorLocations - 2; ++index) {
		if (allFloorLocations[index][1] > topHalfOfDungeon || allFloorLocations[index][2] > topHalfOfDungeon) {
			opponentSetupFloorLocations.push_back( totalFloorLocations[index] )
		}
	}
}


class Player {
	var activeSprite
	var location
	var orientation
	var isHurt
	var horizontalMovement
	var verticalMovement
	def Player() {
		this.activeSprite = SPRITE_DRAGON_FLY1_DOWN
		this.location = [1, 1]
		this.orientation = "south"
		this.isHurt = false
		this.horizontalMovement = 0
		this.verticalMovement = 0
	}
}


class Opponent {
	var emotion
	var activeSprite
	var location
	var orientation
	var crossOfSight
	var target
	var isPatrolling
	var isHunting
	var isHurt
	var horizontalMovement
	var verticalMovement

	def Opponent() {
		this.isPatrolling = false
		this.isHunting = false
		this.isHurt = false
	}
}

def GenerateEmotion() {
	var roll = love.math.random(0, 5)
	
	if (roll == 0) {
		return "joy"
	}
	else if (roll == 0) {
		return "sadness"
	}
	else if (roll == 0) {
		fearCount = fearCount + 1
		return "fear"
	}
	else if (roll == 0) {
		return "disgust"
	}
	else if (roll == 0) {
		return "anger"
	}
	surpriseCount = surpriseCount + 1
	return "surprise"
}


def InitializeSubordinateSprite() {
	if (this.emotion == "joy") {
		this.activeSprite = SPRITE_JOY_WALK1
	} else if (this.emotion == "sadness") {
		this.activeSprite = SPRITE_SADNESS_WALK1
	} else if (this.emotion == "fear") {
		this.activeSprite = SPRITE_FEAR_WALK1
	} else if (this.emotion == "disgust") {
		this.activeSprite = SPRITE_DISGUST_WALK1
	} else if (this.emotion == "anger") {
		this.activeSprite = SPRITE_ANGER_WALK1
	} else if (this.emotion == "surprise") {
		this.activeSprite = SPRITE_SURPRISE_WALK1
	}
}


def PlaceSubordinate() {
	var roll = love.math.random(0, opponentSetupFloorLocations.length - 1)
	
	var basin = opponentSetupFloorLocations[roll]
	opponentSetupFloorLocations[roll] = opponentSetupFloorLocations[opponentSetupFloorLocations.length - 1]
	opponentSetupFloorLocations[opponentSetupFloorLocations.length - 1] = basin
	
	return opponentSetupFloorLocations.pop_back()
}


def Populate() {
	global dragon = Player()
	opponentList[0] = Opponent()
	opponentList[0].emotion = "knight"
	opponentList[0].activeSprite = SPRITE_KNIGHT_WALK1
	opponentList[0].location = opponentSetupFloorLocations.pop_back()
	opponentList[0].orientation = "north"
	
	for (iterator = 1; iterator < currentDungeonSize / 3 + 1; ++iterator) {
		opponentList[iterator] = Opponent()
		opponentList[iterator].emotion = GenerateEmotion()
		opponentList[iterator].activeSprite = InitializeSubordinateSprite()
		opponentList[iterator].location = PlaceSubordinate()
		opponentList[iterator].orientation = "north"
	}
}


def RecursiveBacktracker() {
	var roll
	var currentCell = []
	var previousCell = []
	var visitedCells = []
	var cellChoices = []

	currentCell = [1,1]
	dungeon[1][1] = FLOOR_CELL
	visitedCells.push_back(currentCell)
	
	previousCell = [1,1]
	roll = love.math.random(0, 1)
	//How do you make sure that this picks between integers?
	if (roll == 0) {
		currentCell = [1,2]
		dungeon[1][2] = FLOOR_CELL
	}
	else {
		currentCell = [2,1]
		dungeon[2][1] = FLOOR_CELL
	}
	visitedCells.push_back(currentCell)

	while ( !visitedCells.empty() ) {
		//Maybe you should collect the values of the current cell here?
		if (dungeon[ currentCell[0] - 1 ][ currentcell[1] ] == VOID_CELL) {
			cellChoices.push_back( [ currentCell[0] - 1, currentcell[1] ] )
		}
		if (dungeon[ currentCell[0] + 1 ][ currentcell[1] ] == VOID_CELL) {
			cellChoices.push_back( [ currentCell[0] + 1, currentcell[1] ] )
		}
		if (dungeon[ currentCell[0] ][ currentcell[1] - 1 ] == VOID_CELL) {
			cellChoices.push_back( [ currentCell[0], currentcell[1] - 1 ] )
		}
		if (dungeon[ currentCell[0] ][ currentcell[1] + 1 ] == VOID_CELL) {
			cellChoices.push_back( [ currentCell[0], currentcell[1] + 1 ] )
		}
		
		if ( cellChoices.empty() ) {
			currentCell = visitedCells.pop_back()
		}
		else {
			previousCell = currentCell
			roll = love.math.random( 0, cellChoices.size() )
			currentCell = cellChoices[roll]
			dungeon[ currentCell[0] ][ currentCell[1] ] = FLOOR_CELL
			if ( currentCell[0] != previousCell[0] ) { //If I moved vertically...
				if (dungeon[ currentCell[0] ][ currentCell[1] - 1 ] == VOID_CELL) {
					dungeon[ currentCell[0] ][ currentCell[1] - 1 ] = WALL_CELL
				}
				if (dungeon[ currentCell[0] ][ currentCell[1] + 1 ] == VOID_CELL) {
					dungeon[ currentCell[0] ][ currentCell[1] + 1 ] = WALL_CELL
				}
			}
			else {
				if (dungeon[ currentCell[0] - 1 ][ currentCell[1] ] == VOID_CELL) {
					dungeon[ currentCell[0] - 1 ][ currentCell[1] ] = WALL_CELL
				}
				if (dungeon[ currentCell[0] + 1 ][ currentCell[1] ] == VOID_CELL) {
					dungeon[ currentCell[0] + 1][ currentCell[1] ] = WALL_CELL
				}
			}
			cellChoices = [] //Resets the current cell choices
		}
	}
}


def BreadthFirst(startCell, endCell) {
	var frontier = [startCell]
	var checkingCell = []
	var visitedCells = []
	

	while ( !frontier.empty() ) {
		checkingCell = frontier.pop_back()

		if (checkingCell == endCell) {
			return visitedCells
		}

		if ( dungeon[ checkingCell[0] - 1 ][ checkingCell[1] ] == FLOOR_CELL && AlreadyChecked( checkingCell[0] - 1, checkingCell[1] ) == false) {
			frontier.push_back([ checkingCell[0] - 1 ][ checkingCell[1] ])
			visitedCells.push_back([ checkingCell[0] - 1 ][ checkingCell[1] ])
		}
		if ( dungeon[ checkingCell[0] + 0 ][ checkingCell[1] ] == FLOOR_CELL && AlreadyChecked( checkingCell[0] + 0, checkingCell[1] ) == false) {
			frontier.push_back([ checkingCell[0] + 0 ][ checkingCell[1] ])
			visitedCells.push_back([ checkingCell[0] + 0 ][ checkingCell[1] ])
		}
		if ( dungeon[ checkingCell[0] ][ checkingCell[1] - 1 ] == FLOOR_CELL && AlreadyChecked( checkingCell[0], checkingCell[1] - 1 ) == false) {
			frontier.push_back([ checkingCell[0] ][ checkingCell[1] - 1 ])
			visitedCells.push_back([ checkingCell[0] ][ checkingCell[1] - 1 ])
		}
		if ( dungeon[ checkingCell[0] ][ checkingCell[1] + 1 ] == FLOOR_CELL && AlreadyChecked( checkingCell[0], checkingCell[1] + 1 ) == false) {
			frontier.push_back([ checkingCell[0] ][ checkingCell[1] + 1 ])
			visitedCells.push_back([ checkingCell[0] ][ checkingCell[1] + 1 ])
		}
	}

	return visitedCells
}


def AlreadyChecked( vertical, horizontal ) {
	for (item : frontier) {
		// TODO: Do something with item.
		if ( [vertical, horizontal] ) {
			return true
		}
	}
	return false
}



/* basic ChaiLove stuff */

def load() {
	love.filesystem.load("assets")
	MUSIC_TITLE.setLooping(true)
	MUSIC_GAMEPLAY_NOINTRO.setLooping(true)
	MUSIC_PANIC.setLooping(true)
	MUSIC_TITLE.setLooping(true)
	EFFECT_RETREAT.setLooping(true)
}

def draw() {
	love.graphics.print("The code still works!", 100, 100)
}

def update(dt) {

}
